#!/usr/bin/env ruby

# frozen_string_literal: true

require "fileutils"
require "json"
require "open-uri"
require "optparse"
require "pathname"
require "shellwords"
require_relative "repo_thumbnail"
require_relative "utils"

CACHE_DIR = ".cache"
REPO_JSON_PATH = "_data/repos.json"
THUMBNAIL_CACHE = File.join(CACHE_DIR, "thumbnails")
THUMBNAIL_IMG_DIR = "static/img/thumbnails"

# TODO: replace this by path relative to README URL
RAW_URL_TPL = "https://raw.githubusercontent.com/${nameWithOwner}/master/"

options = {}
OptionParser.new do |opts|
  # opts.banner = "Usage: update_thumbnails [options]"

  opts.on("-P", "--pattern PATTERN", "Update repos matching pattern") do |p|
    options[:pattern] = p
  end
  opts.on("-f", "--force", "Force updates") do |f|
    options[:force] = f
  end
  opts.on("-v", "--[no-]verbose", "Run verbosely") do |v|
    options[:verbose] = v
  end
end.parse!
verbose = options[:verbose]

repos = read_json(REPO_JSON_PATH)

# Update nwo's thumbnail path. Write the file immediately, since this doesn't
# add much time and makes the next run faster if we're stopped in the middle.
def update_thumbnail_path(repos, nwo, thumbnail_path)
  relpath = thumbnail_path && Pathname.new(thumbnail_path).relative_path_from(
    Pathname.new(THUMBNAIL_CACHE)
  ).to_s
  repo = repos.find { |r| r["nameWithOwner"] == nwo }
  return if repo["thumbnailPath"] == relpath

  repo["thumbnailPath"] = relpath
  write_json(REPO_JSON_PATH, repos)
end

# rubocop:disable BlockLength
repos.sort_by { |r| r["nameWithOwner"] }.each do |repo|
  nwo = repo["nameWithOwner"]
  next if options[:pattern] && nwo != options[:pattern]

  raw_url_prefix = RAW_URL_TPL.sub("${nameWithOwner}", nwo)
  metadata_path = File.join(THUMBNAIL_CACHE, nwo, "metadata.json")
  FileUtils.mkdir_p File.dirname(metadata_path)
  metadata = File.exist?(metadata_path) ? read_json(metadata_path) : {}

  is_missing = metadata["is_missing"] == true
  thumbnail_path = metadata["thumbnail_path"]
  if !options[:force] && (is_missing || thumbnail_path)
    if is_missing
      puts "#{nwo}: no image (cached)" if verbose
      update_thumbnail_path(repos, nwo, nil)
    else
      puts "#{nwo}: #{thumbnail_path} (cached)" if verbose
      update_thumbnail_path(
        repos, nwo,
        File.join(THUMBNAIL_CACHE, nwo, thumbnail_path)
      )
    end
    next
  end

  print "#{nwo}: "
  STDOUT.flush
  readme_data = get_repo_readme_data(nwo) || {}
  readme_name = readme_data[:name]
  metadata[:readme_name] = readme_name
  matches = get_markdown_images(remove_initial_badges(readme_data[:content] || ""))
            .map { |s| s.sub(/\?.*/, "") }
  # For now, only consider on-site images
  matches = matches.reject { |s| s.match(/^https?:/) }
  unless matches.any?
    puts(readme_name ? "no image in #{readme_name}" : "no README")
    Dir.glob(File.join(THUMBNAIL_CACHE, nwo, "thumbnail.*")).each do |path|
      FileUtils.rm path
    end
    metadata["is_missing"] = true
    metadata["thumbnail_path"] = nil
    update_thumbnail_path(repos, nwo, nil)
    write_json(metadata_path, metadata)
    next
  end

  thumbnail_rel_url = matches.first
  metadata["thumbnail_url"] = thumbnail_rel_url
  thumbnail_url = URI.join(raw_url_prefix, thumbnail_rel_url).to_s
  thumbnail_ext = File.extname(thumbnail_url)
  thumbnail_path = File.join(THUMBNAIL_CACHE, nwo, "thumbnail#{thumbnail_ext}")

  puts "#{thumbnail_url} -> #{thumbnail_path}"
  FileUtils.mkdir_p File.dirname(thumbnail_path)
  URI.parse(thumbnail_url).open do |f|
    IO.copy_stream(f, thumbnail_path)
  end
  update_thumbnail_path(repos, nwo, thumbnail_path)
  metadata["is_missing"] = false
  metadata["thumbnail_path"] = File.basename(thumbnail_path)
  update_thumbnail_path(repos, nwo, nil)
  write_json(metadata_path, metadata)
end
# rubocop:enable BlockLength

puts "\nCopy #{THUMBNAIL_CACHE} -> #{THUMBNAIL_IMG_DIR}" if verbose
FileUtils.mkdir_p File.dirname(THUMBNAIL_IMG_DIR)
system <<~"SHELL"
  rsync \
    #{Shellwords.escape THUMBNAIL_CACHE}/ \
    #{Shellwords.escape THUMBNAIL_IMG_DIR} \
    #{verbose ? '--verbose' : '--quiet'} \
    --checksum \
    --delete \
    --exclude metadata.json \
    --exclude .DS_Store \
    --prune-empty-dirs \
    --recursive
SHELL
